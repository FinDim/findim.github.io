<html><head><title>FinDim's Software Engineering Notes</title>
<style>
:root {
    --color1: #25274d;
    --color2: #464866;
    --color3: #aaabb8;
    --color4: #2e9cca;
    --color5: #29648a;
    --black: #202020;
    --white: #f0f0f0;
}
body { font-family: sans-serif; background-color: var(--black); color: var(--white); }
div { width: 80ch; height: 120%; border-left: 8px solid var(--color2); padding: 8px; }
h1 { border-bottom: 4px solid var(--color2); margin-top: 0px; margin-bottom: -10px; margin-left: -25px; padding-left: 25px; }
h2 { border-bottom: 3px solid var(--color2); margin-bottom: -10px; margin-left: -25px; padding-left: 25px; }
p { font-family: serif;  }
.light { color: var(--color3); }
pre { background-color: #1d1d1d; padding: 8px; margin-left: 10px; width: 80ch; }
</style>
</head>
<body><div>
<h1>FinDim's software engineering notes</h1>
<p class="light"><i>Candid notes from my personal journey as a software engineer</i></p>
<h2>Formatting quick reference</h2>
<h3>header 3</h3>
<p>Paragraph text.  For small (in size) problems, modern computers are
sufficiently fast that straightforward brute-force solutions are often fast
enough for all practical purposes.  For example, sorting ten numbers is fast
even with brute-force, sorting a trillion numbers calls for a smarter approach.
<p>Algorithm design is hard in subtle ways, in particular, it is easy to write an
algorithm that seems intuitively correct but fails on some cases.  Proving
correctness requires often complex mathematical proofs to ensure all edge cases
are accounted.
<pre>
import math

# 80 char line
01234567890123456789012345678901234567890123456789012345678901234567890123456789

# some assertions
assert math.sqrt(8**2) == 8
assert math.sqrt(12**2) == 12
</pre>
<p>Following paragraph begins here.
</div></body></html>
